import { useRef, useEffect, useState } from "react";
import "../app/globals.css";

import { Canvas, useFrame, useLoader } from "@react-three/fiber";
import {
  Center,
  Environment,
  Backdrop,
  ContactShadows,
} from "@react-three/drei";
import { TextureLoader } from "three/src/loaders/TextureLoader";
import { useGLTF } from '@react-three/drei'
import * as THREE from 'three'; // Import THREE from the 'three' library




export default function App() {
  const [progress, setProgress] = useState(0);

  useEffect(() => {
    // Simulate progress change over time
    const interval = setInterval(() => {
      // Update progress at regular intervals
      // For example, update progress every second
      const newProgress = (progress + 1) % 101; // Increment progress by 1 every second
      setProgress(newProgress);
    }, 1000); // Update progress every second

    return () => clearInterval(interval); // Cleanup interval on component unmount
  }, [progress]); // Re-run effect whenever progress changes

  return (
    <div style={{ width: "100vw", height: "100vh", position: "relative" }}>
      <div
        style={{
          display: "flex",
          flexDirection: "column",
          justifyContent: "center",
          alignItems: "center",
          position: "absolute",
          top: "0",
          left: "25%",
          width: "100vw",
          height: "100vh",
          zIndex: 1,
          marginTop: "-5em",
        }}
      >
        <div
          style={{
            lineHeight: "1em",
            textAlign: "left",
            fontSize: "4.3em",
            wordBreak: "break-word",
            fontFamily: "Aeonik-Regular",
            color: "rgba(255, 255, 255, 1)",
          }}
        >
          Toda Beleza{" "}
        </div>
        <div
          style={{
            lineHeight: "1em",
            textAlign: "left",
            fontSize: "3.2em",
            fontFamily: "Aeonik-Regular",
            color: "rgba(255, 255, 255, 0.5)",
            marginTop: "0.2em",
          }}
        >
          Rubel{" "}
        </div>
        {/* Progress bar */}
        <div
          style={{
            position: "absolute",
            top: "65%",
            left: "50%",
            transform: "translateX(-50%)",
            width: "25%",
            height: "5px",
            backgroundColor: "rgba(255, 255, 255, 0.2)",
            borderRadius: "5px",
            overflow: "hidden",
          }}
        >
          <div
            style={{
              width: `${progress}%`,
              height: "100%",
              backgroundColor: "#fff",
              transition: "width s ease", // Add smooth transition animation
            }}
          />
        </div>
      </div>

      <Canvas linear shadows>
        <CombinedMeshes progress={setProgress} />{" "}
        <Hand position={new THREE.Vector3(0, 0, 0)} /> {/* Set the initial position here */}
        <Backdrop
          castShadow
          floor={2}
          position={[0, -4.5, 0]}
          scale={[50, 10, 4]}
        >
          <meshStandardMaterial color="#091227" envMapIntensity={6.5} />
        </Backdrop>
        <ContactShadows
          position={[-0.1, -1.5, -0.58]}
          scale={8}
          blur={3.5}
          opacity={0.5}
        />
        <Environment preset="sunset" background blur={1} />
      </Canvas>
    </div>
  );
}


function Hand({ position }) {
  const { nodes } = useGLTF('./3DModels/hand.gltf');
  const [animationStep, setAnimationStep] = useState(0);

  const steps = [
    { position: [50, -500, -2], duration: 2 },
    { position: [50, -65, -2], duration: 2 },
    { position: [50, 0, -2], duration: 3 },
    { position: [50, -85, -2], duration: 3 },
    { position: [50, 25, -2], duration: 3 },
    { position: [50, -65, -2], duration: 3 },
    { position: [50, -500, -2], duration: 2 },
  ];

  useFrame((state, delta) => {
    // Access position directly
    const step = steps[animationStep];
    const targetPosition = new THREE.Vector3(...step.position);
    const currentPosition = new THREE.Vector3().copy(position);
    const duration = step.duration * 1000;
    const progress = Math.min(1, state.clock.elapsedTime / duration);
    
    position.set(
      (currentPosition.x, targetPosition.x, progress),
      (currentPosition.y, targetPosition.y, progress),
      (currentPosition.z, targetPosition.z, progress)
    );

    if (progress >= 1) {
      setAnimationStep((animationStep + 1) % steps.length);
    }
  });

  return (
    <group dispose={null}>
      <group scale={0.01}>
        <group position={[50, 0, -2]} rotation={[-0.415, -0.043, -0.019]} scale={0.559}>
          <mesh geometry={nodes.Cylinder.geometry} material={nodes.Cylinder.material} position={[18.199, -95.575, 16.796]} rotation={[-Math.PI, 0, -Math.PI]} scale={[2.027, 2.027, 1.396]} />
          <mesh geometry={nodes['hand-3'].geometry} material={nodes['hand-3'].material} position={[23.998, -11.39, 3.544]} rotation={[-Math.PI, 0, -Math.PI]} scale={1.549} />
        </group>
        <directionalLight intensity={0.7} decay={2} rotation={[-0.506, 0.629, 0.756]} />
      </group>
    </group>
  )
}



function CombinedMeshes({ progress }) {
  const ref = useRef();
  const cubeRef = useRef();

  useFrame((state) => {
    const t = state.clock.getElapsedTime();
  
    // Update rotation and position for the music player mesh
    ref.current.rotation.set(
      Math.cos(t / 4) / 16,
      Math.sin(t / 4) / 16,
      -0 - (1 + Math.sin(t / 1.5)) / 40
    );
    ref.current.position.y = -2 - (2 + Math.sin(t / 2)) / 10;
    ref.current.position.x = -3;
    ref.current.scale.set(3.8, 3.8, 3.8);
    ref.current.rotation.y = 0.09;
  
    // Update rotation for the cylinderGeometry to make it spin around its center
    const cylinder = ref.current.children[2]; // Assuming the cylinder is the third child
    const cubeYPosition = cubeRef.current.position.y;
    const rotationDirection = cubeYPosition >= 0 ? 1 : -1; // Adjust rotation direction based on cube's position
    const rotationValue = rotationDirection * t;
    cylinder.rotation.z = rotationValue;
  
    // Update position for the cube
    const amplitude = 2; // Set the desired amplitude (e.g., 1 for half the distance)
    cubeRef.current.position.y = (Math.sin(t) * amplitude);

    const progressValue = 55 + 10 * Math.sin(t); // Progress value between 55 and 80
    progress(progressValue); // Update progress value
  });

  const musicPlayerTexture = useLoader(TextureLoader, "Vinyl_Cover-2.png");
  const musicPlayerEnv = useLoader(TextureLoader, "cover_ao 1.png");

  const diskTexture = useLoader(TextureLoader, "disk_texture.png");

  return (
    <group ref={ref}>
      <group>
        <Center top>
          <mesh castShadow>
            <boxGeometry args={[1.3, 1.3, 0.03]} />
            <meshStandardMaterial
              metalness={0.9}
              roughness={0.08}
              map={musicPlayerTexture}
              lightMap={musicPlayerEnv}
              lightMapIntensity={300}
            />
          </mesh>
        </Center>
      </group>

      <group position={[1, 0, 0]} ref={cubeRef}>
        <mesh castShadow>
          <boxGeometry args={[0.1, 0.1, 0]} />
          <meshStandardMaterial color="rgba(255, 255, 255, 0)"/>
        </mesh>
      </group>

      <group position={[0.4, 0.65, -0.05]}>
        {" "}
        <mesh castShadow rotation={[Math.PI / 2, 0, 0]}>
          <cylinderGeometry args={[0.55, 0.55, 0.0, 128]} />
          <meshStandardMaterial
            metalness={0.9}
            roughness={0.08}
            map={diskTexture}
            lightMap={diskTexture}
          />
        </mesh>
      </group>
    </group>
  );
}
